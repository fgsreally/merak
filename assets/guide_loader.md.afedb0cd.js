import{_ as e,o,c as d,a}from"./app.ca02e63f.js";const _=JSON.parse('{"title":"加载器","description":"","frontmatter":{},"headers":[{"level":2,"title":"CompileLoader(默认使用)","slug":"compileloader-默认使用","link":"#compileloader-默认使用","children":[]},{"level":2,"title":"SSRLoader","slug":"ssrloader","link":"#ssrloader","children":[]},{"level":2,"title":"RuntimeLoader","slug":"runtimeloader","link":"#runtimeloader","children":[]}],"relativePath":"guide/loader.md","lastUpdated":1700400907000}'),c={name:"guide/loader.md"},r=a('<h1 id="加载器" tabindex="-1">加载器 <a class="header-anchor" href="#加载器" aria-hidden="true">#</a></h1><p>加载器负责获得<code>html</code>并进行处理</p><h2 id="compileloader-默认使用" tabindex="-1"><code>CompileLoader</code>(默认使用) <a class="header-anchor" href="#compileloader-默认使用" aria-hidden="true">#</a></h2><p>编译端将子应用中<code>script</code>,<code>link</code>标签位置标明，并添加到一个新标签上</p><p><code>CompileLoader</code>拿到<code>html</code>，读取标签信息并修改<code>html</code>,返回给<code>merak</code></p><blockquote><p>当编译端设置<code>output</code>时，会将信息写入一个<code>json</code>,设置<code>loaderOptions</code>为文件的<code>url</code>，其就会从<code>json</code>中读取信息，而不用新标签了</p></blockquote><h2 id="ssrloader" tabindex="-1"><code>SSRLoader</code> <a class="header-anchor" href="#ssrloader" aria-hidden="true">#</a></h2><p>直接从主应用<code>html</code>中获取对应的子应用模板，后续流程和<code>CompileLoader</code>一致</p><h2 id="runtimeloader" tabindex="-1"><code>RuntimeLoader</code> <a class="header-anchor" href="#runtimeloader" aria-hidden="true">#</a></h2><blockquote><p>当编译端<code>loader</code>为<code>runtime</code>时使用</p></blockquote><p>在浏览器中通过正则处理<code>script/link</code>的路径问题</p>',11),l=[r];function t(i,n,s,p,h,m){return o(),d("div",null,l)}const k=e(c,[["render",t]]);export{_ as __pageData,k as default};
