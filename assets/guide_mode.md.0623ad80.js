import{_ as s,o as a,c as l,a as e}from"./app.b2a592f6.js";const C=JSON.parse('{"title":"模式","description":"","frontmatter":{},"headers":[{"level":2,"title":"keep-alive","slug":"keep-alive","link":"#keep-alive","children":[]},{"level":2,"title":"iframe模式","slug":"iframe模式","link":"#iframe模式","children":[]},{"level":2,"title":"库模式","slug":"库模式","link":"#库模式","children":[]},{"level":2,"title":"ssr","slug":"ssr","link":"#ssr","children":[]},{"level":2,"title":"服务端","slug":"服务端","link":"#服务端","children":[]},{"level":2,"title":"客户端","slug":"客户端","link":"#客户端","children":[]}],"relativePath":"guide/mode.md","lastUpdated":1693230436000}'),o={name:"guide/mode.md"},n=e(`<h1 id="模式" tabindex="-1">模式 <a class="header-anchor" href="#模式" aria-hidden="true">#</a></h1><p>默认定义了<code>merak-app</code>这个<code>webcomponent</code>，存在<code>keep-alive</code>和<code>iframe</code>模式(彼此并不冲突)。</p><p>提供了更多的模式并不是希望使用者使用更多的模式。说句大实话，微前端的隐患是无穷无尽的，不同的设计思路只不过是遇上不同的问题，但也许当下你遇到的问题在另一种思路下可以轻松解决，这才是多模式的意义所在。</p><p>当遇上问题的时候，也许可以换个模式试试</p><h2 id="keep-alive" tabindex="-1">keep-alive <a class="header-anchor" href="#keep-alive" aria-hidden="true">#</a></h2><p>详见<a href="./lifecycle.html">keep-alive</a></p><h2 id="iframe模式" tabindex="-1">iframe模式 <a class="header-anchor" href="#iframe模式" aria-hidden="true">#</a></h2><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> app </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Merak</span><span style="color:#A6ACCD;">(name</span><span style="color:#676E95;font-style:italic;">/** 子应用name */</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> url</span><span style="color:#676E95;font-style:italic;">/** 子应用url */</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">iframe</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">iframeid</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>这会使所有<code>js</code>在<code>iframe</code>中执行，销毁时移除<code>iframe</code>从而保证资源完全释放 注意 ，同一个<code>iframeid</code>的子应用会被分配到同一个<code>iframe</code>中执行<code>js</code></p><div class="tip custom-block"><p class="custom-block-title">提醒</p><ol><li>子应用可以不暴露钩子，原因详见<a href="./idea/question-from.html#难以面面俱到的隔离">详见</a></li><li>当不打开<code>keep-alive</code>,这和无界的<a href="./.html">重建模式</a>一致</li><li>不优先考虑，但如果子应用始终出现不明原因的错误，可以尝试一下不打开<code>keep-alive</code>的同时使用<code>iframe模式</code></li><li>如果你需要同时打开子应用的两个路由页面，只需创建两个实例，保证<code>iframeid</code>不相同就好</li></ol></div><h2 id="库模式" tabindex="-1">库模式 <a class="header-anchor" href="#库模式" aria-hidden="true">#</a></h2><p>如果执意使用模块联邦等方案（引入的是<code>js</code>文件而非<code>html</code>），<code>天璇</code>提供了库模式，当挂载一个组件时（如果对象只是一段普通脚本而非一个需要挂载的组件，意义较小，因为这样没有必要<code>dom</code>隔离），会给它提供一个单独的上下文进行,对其进行隔离</p><blockquote><p>包括<code>dom</code>/<code>style</code>/<code>js</code>的隔离</p></blockquote><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> app </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Merak</span><span style="color:#A6ACCD;">(name</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> url</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">proxy</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">createLibProxy</span><span style="color:#A6ACCD;">(name</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> url) </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">merak-block</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">data-merak-id</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">id</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">data-merak-varname</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">分配的变量名</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">merak-block</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">提醒</p><ol><li>这是个实验性质的功能</li><li>优点\\缺点和普通模式一样</li><li>没有对<code>location</code>,<code>history</code>的隔离</li></ol></div><h2 id="ssr" tabindex="-1">ssr <a class="header-anchor" href="#ssr" aria-hidden="true">#</a></h2><blockquote><p>实验性功能</p></blockquote><p>当主子应用均为<code>ssr</code>时，子应用的<code>ssr</code>效果能在主应用中起效</p><h2 id="服务端" tabindex="-1">服务端 <a class="header-anchor" href="#服务端" aria-hidden="true">#</a></h2><p>服务端需要做一定改造，需往<code>html</code>中加入一段<code>template</code>：</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">html</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  ...</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">id</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">项目id</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">merak-config</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">{&quot;fakeGlobalVar&quot;:&quot;name&quot;}</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">&lt;!-- 子应用的ssr渲染结果 --&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">template</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">html</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div><blockquote><p><code>template</code> 只是模板，里面的东西既不会渲染也不会执行</p></blockquote><div class="tip custom-block"><p class="custom-block-title">注意</p><p>请注意：这不是真正的<code>ssr</code>,它并不能“跑”在服务端中，毕竟，操作dom是不可回避的事情。</p><p>它只是通过注入一段<code>template</code>到<code>html</code>中，在客户端渲染时，直接拿到<code>template</code>进行渲染。</p><p>简而言之，对<code>seo</code>和<code>首屏渲染</code>均有助益，对<code>ssr</code>使用者应该足够有吸引力</p></div><h2 id="客户端" tabindex="-1">客户端 <a class="header-anchor" href="#客户端" aria-hidden="true">#</a></h2><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> app </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Merak</span><span style="color:#A6ACCD;">(id</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> url)</span></span>
<span class="line"></span></code></pre></div><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">merak-ssr</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">data-merak-id</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">项目id</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">merak-ssr</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div>`,27),p=[n];function t(c,r,i,d,D,y){return a(),l("div",null,p)}const h=s(o,[["render",t]]);export{C as __pageData,h as default};
