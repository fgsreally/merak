import{_ as e,o,c as a,Q as c}from"./chunks/framework.57e4d220.js";const k=JSON.parse('{"title":"Merak设计思路","description":"","frontmatter":{},"headers":[],"relativePath":"blog/core.md","filePath":"blog/core.md","lastUpdated":1713971802000}'),d={name:"blog/core.md"},r=c('<h1 id="merak设计思路" tabindex="-1">Merak设计思路 <a class="header-anchor" href="#merak设计思路" aria-label="Permalink to &quot;Merak设计思路&quot;">​</a></h1><h2 id="凡是能在编译完成的-不要交给运行时" tabindex="-1">凡是能在编译完成的，不要交给运行时 <a class="header-anchor" href="#凡是能在编译完成的-不要交给运行时" aria-label="Permalink to &quot;凡是能在编译完成的，不要交给运行时&quot;">​</a></h2><p>其实最早,这个方案更像是<code>garfish</code>中的<code>esmloader</code>,是一个纯粹的运行时方案，先请求来js，在worker中编译，创建虚拟<code>url</code>,然后挂载到页面。</p><p>但当我处理<code>publicpath</code>的时候，发现<code>base</code>标签动态更改不起效，也无法直接修正<code>img</code>等元素的<code>baseurl</code>,即使劫持诸如<code>img</code>的<code>src</code>等属性（无界就是这么做的）,也不是一个好办法（因为有可能直接更改<code>innerHtml</code>，除非你愿意在运行时中放入一个<code>html</code>编译器）。</p><p>我发现最有效的仍是在子应用端设置<code>publicpath</code>。</p><p>这个时候我就感觉，也许一味追求子应用无改造不是一个好选择，实际上也不可能：子应用中要么需要设置路由的<code>base</code>，要么需要分辨是否为子应用，并执行对应的逻辑，如果遇上依赖库有某种bug，这种改造会更加繁琐。</p><p>我也许可以在编译处动点手脚，把子应用改造的多一点，让运行时少做一点</p><h2 id="merak做了什么" tabindex="-1">merak做了什么 <a class="header-anchor" href="#merak做了什么" aria-label="Permalink to &quot;merak做了什么&quot;">​</a></h2><h3 id="编译时" tabindex="-1">编译时 <a class="header-anchor" href="#编译时" aria-label="Permalink to &quot;编译时&quot;">​</a></h3><p><code>merak</code>现在在编译端做了三件事，</p><ol><li>把需要被隔离的变量，找出来并更改指向，</li><li>是把样式规则改为符合<code>shadowroot</code>的格式（<code>root</code> to <code>host</code>），</li><li>是找到<code>html</code>中<code>script</code>,<code>link</code>等的入口</li></ol><p>如果要对<code>merak</code>做自定义的改造,请沿袭这个思路，在编译时多动点手脚</p>',12),t=[r];function l(i,s,h,n,p,m){return o(),a("div",null,t)}const u=e(d,[["render",l]]);export{k as __pageData,u as default};
