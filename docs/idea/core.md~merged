# Merak设计思路

## 凡是能在编译完成的，不要交给运行时
> inspierd from svelte
其实最早,这个方案更像是`garfish`中的`esmloader`,是一个纯粹的运行时方案，先请求来js，在worker中编译，创建虚拟`url`,然后挂载到页面。

但当我处理`publicpath`的时候，发现`base`标签动态更改不起效，也无法直接修正`img`等元素的`baseurl`,即使劫持诸如`img`的`src`等属性（无界就是这么做的）,也不是一个好办法（因为有可能直接更改`innerHtml`），我发现最有效的仍是在子应用端设置`publicpath`。

<<<<<<< HEAD
这个时候我就感觉，也许一味追求子应用无改造不是一个好选择，实际上也不可能：子应用中要么需要设置路由的`base`，要么需要分辨是否为子应用，并执行对应的逻辑，如果遇上依赖库有某种bug，这种改造会更加繁琐。

我也许可以在编译处动点手脚，把子应用改造的多一点，让运行时少做一点

`merak`现在在编译端做了三件事，一是把需要被隔离的变量，找出来并更改指向，二是把样式规则改为符合`shadowroot`的格式（`root` to `host`），三是找到`html`中`script`,`link`的入口

如果要对`merak`做自定义的改造,请沿袭这个思路，在编译时多动点手脚

=======
这个时候我就感觉，也许一味追求子应用无改造不是一个好选择，实际上也不可能，子应用中要么需要设置路由的`base`，要么需要分辨是否为子应用，并执行对应的逻辑，也许可以在编译处动点手脚

`merak`现在在编译端做了三件事，一是把需要被隔离的变量，找出来并更改指向，二是把样式规则改为符合`shadowroot`的格式（`root` to `host`），三是找到`html`中`script`,`link`的入口

如果要对`merak`做自定义的[改造](),请沿袭这个思路，在编译时多动点手脚

## 相比于其他框架

我认为这些方面是需要被关注的

1. `esm`支持 
`merak`对不同的打包器，视图框架,模块加载方案一视同仁，可以在任何环境中，获得完全一致的体验，如`qiankun`等框架,当使用`vite`时，要么需要舍弃一部分功能，要么需要做彻底的改造,比如降级成`systemjs`


2. 性能高，
从`js`执行层面，`merak`只会在`proxy`这一层损失性能，而其他框架会在`proxy`外至少经过一层额外的性能损耗，
从资源请求层面，`merak`是等同于原生的请求，而其他框架则存在`custom fetch`去对`fetch`进行重写
从`dom`层面，没有对`dom`的追踪，如`garfish`等中，均是对`createElement`做劫持，从而追踪`dom`，`无界`稍有不同,但也追踪了`style`中的相应样式规则
从样式层面，没有做任何事情，既不需要如`qiankun`中为样式加前缀（虽然这不是硬式需求），也不需要如`wujie`在子应用中抓取`root`等样式进行改造

> 我没有办法举个具体的例子来做对比，因为不同业务场景中负担不同，模拟创建1000个组件然后挂载，这并不符合真实情况，我只能说，性能的损耗，将不会来自于`merak`

> 因为`框架`这个层面不再创造性能消耗，性能问题将完全回归应用本身，微前端不再是用性能换维护的模式，也不再是B端的专属话题，可以在更多的领域尝试它


3. 更低的bug可能
可以看`wujie`的(issue)[issue] 以及()[歧义性]，很多问题的来源并不是框架本身，而是某个用到的库内部存在奇思妙想，用了一些可能不是那么正规的写法，然后框架本身又劫持了所有的`script`请求与拔插，导致执行环境与单独运行有一定不同，致使这种不正规情况爆发隐患。`merak`本身不对`script`/`style`做任何劫持，仍使用原生请求


4. 可拆分的功能
其余框架追求内部状态封闭，从而暴露简洁的`api`,很多时候使用者都会从中受益，但一旦遇到特殊的情况，或许是微前端框架自己的`bug`，也或许是特殊的需求，使用者就有点骑虎难下，明明觉得很多功能很合适，但却因为一个小问题不得不放弃使用。
`merak`分为三部分，一部分是编译时，一部分是沙箱，还有一部分是 `Merak`实例+`webcomponent`，控制应用加载和挂载，开发者可以自由拆卸这些功能，
> 比如现在的`merak-ssr`组件，还处于实验状态，你可以保留编译时和沙箱，增加一个自己的`ssr web component`,创建一个`Merak`的子类，修改方法，从而实现自定义的`ssr`效果
> 又比如部分沙箱功能不符合预期，比如你可能不喜欢这种无界式，基于`query`的路由分配，而更喜欢`qiankun`的路由分配，只需要去更改沙箱的`location`,`history`即可（比如库模式，就是舍去了沙箱这两部分[详见]()），又比如，你希望子应用的`load`之类的事件正确触发，那可以自定义沙箱中的`window`规则，[详见]()

5. ssr
目前来讲，应该没有能支持`ssr`的微前端方案，
目前`merak`有实验性的支持（之所以是实验性，并不是它有问题or不可靠，而是其表现与`spa`中有微微不同，我更希望两者能表现相同，所以暂定为实验性），服务端侧的改造可以看[例子](),这个没有强制的规定，可以用流式之类的方法实现
<<<<<<< HEAD:docs/idea/compare.md
> 补充：`single-spa`有相关尝试，但思路奇妙,过于理想化了
=======
> 补充：`single-spa`有相关尝试，但思路比较奇妙...
>>>>>>> e355afc9ac166494df509deb80ca49ae1d04384c:docs/idea/core.md

### 隐患
> 很多时候，问题并没有消失，只是从一种变成了另一种
1. 如`eval`/字符串拼凑`script`等依赖运行时创造的环境（动态副作用），无法自动隔离
2. 子应用必须做改造，也就是所有用到的`js`文件必须编译，如未改造的`cdn`中，无法自动隔离
3. 
>>>>>>> e355afc9ac166494df509deb80ca49ae1d04384c
