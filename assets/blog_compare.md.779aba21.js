import{_ as o,o as e,c,Q as d}from"./chunks/framework.4b8f86ba.js";const b=JSON.parse('{"title":"比较","description":"","frontmatter":{},"headers":[],"relativePath":"blog/compare.md","filePath":"blog/compare.md","lastUpdated":1708421016000}'),t={name:"blog/compare.md"},l=d('<h1 id="比较" tabindex="-1">比较 <a class="header-anchor" href="#比较" aria-label="Permalink to &quot;比较&quot;">​</a></h1><p>相比于其他框架，我认为这些方面是需要被关注的</p><ul><li><strong><code>esm</code>支持</strong></li></ul><p><code>merak</code>对不同的打包器/视图框架/模块加载方案一视同仁，可以在任何环境中，获得完全一致的体验</p><ul><li><strong>高性能</strong></li></ul><ol><li><p>从<code>js</code>执行层面：<br><code>merak</code>只会在<code>proxy</code>这一层损失性能，而其他框架会在<code>proxy</code>外至少经过一层额外的性能损耗，</p></li><li><p>从资源请求层面：<br> 等同于原生的请求，而其他框架则存在<code>custom fetch</code>去对<code>fetch</code>进行重写</p></li><li><p>从<code>dom</code>层面：<br> 没有对<code>dom</code>的追踪，如<code>garfish</code>等中，均是对<code>createElement</code>做劫持，从而追踪<code>dom</code>，<code>无界</code>稍有不同,但也追踪了<code>style</code>中的相应样式规则</p></li><li><p>从样式层面：<br> 没有做任何事情，没有样式追踪，没有样式改造</p></li></ol><blockquote><p>我没有办法举个具体的例子来做对比，因为不同业务场景中负担不同，模拟创建1000个组件然后挂载，这并不符合真实情况，我只能说，性能的损耗，将不会来自于<code>merak</code>本身</p></blockquote><blockquote><p>因为<code>框架</code>这个层面不再创造性能消耗，性能问题将完全回归应用本身，微前端不再是用性能换维护的模式，也不再是B端的专属话题，可以在更多的领域尝试它</p></blockquote><ul><li><strong>更低的bug可能</strong></li></ul><p>微前端中很多问题的来源并不是框架本身，而是某个用到的库内部存在奇思妙想，用了一些可能不是那么正规的写法，然后框架本身可能基于性能或其他，做了一些干涉（比如劫持<code>script</code>请求与拔插），导致执行环境与单独运行有一定不同，致使这种不正规情况爆发隐患。</p><p><code>merak</code>本身尽量减少对浏览器原生行为的干涉，减少冲突的可能，即使出现问题，也会降低排查难度</p><ul><li><strong>可拆分的功能</strong></li></ul><p>其余框架追求内部状态封闭，从而暴露简洁的<code>api</code>,很多时候使用者都会从中受益，但一旦遇到特殊的情况，或许是微前端框架本身的<code>bug</code>，也或许是特殊的需求，使用者就有点骑虎难下，明明觉得很多功能很合适，但却因为一个小问题不得不放弃使用。</p><p><code>merak</code>分为三部分，一部分是编译时，一部分是沙箱，还有一部分是控制应用加载和挂载的<code>Merak</code>实例+<code>webcomponent</code>，</p><p>开发者可以自由拆卸组装这些功能，制作独属于自己的微前端框架</p><blockquote><p>比如部分沙箱功能不符合预期，比如你可能不喜欢这种无界的基于<code>query</code>的路由分配，而更喜欢<code>qiankun</code>的路由分配，只需要去更改沙箱的<code>location</code>,<code>history</code>即可，又比如，你希望子应用的<code>load</code>之类的事件正确触发，那可以自定义沙箱中的<code>window</code>规则</p></blockquote><ol start="5"><li><strong>SSR</strong><br> 目前来讲，应该没有能支持<code>ssr</code>的微前端方案， 服务端侧的改造可以看<code>example</code>,这个没有强制的规定，流式也是支持的</li></ol><blockquote><p><code>single-spa</code>、<code>cloudflare</code>团队在这方面均有相关尝试，但大多不现实</p></blockquote>',18),r=[l];function a(p,s,i,n,u,m){return e(),c("div",null,r)}const g=o(t,[["render",a]]);export{b as __pageData,g as default};
