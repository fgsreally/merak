import{_ as e,o,c as l,Q as c}from"./chunks/framework.b57a1379.js";const h=JSON.parse('{"title":"目标","description":"","frontmatter":{},"headers":[],"relativePath":"blog/goal.md","filePath":"blog/goal.md","lastUpdated":1707733319000}'),d={name:"blog/goal.md"},i=c('<h1 id="目标" tabindex="-1">目标 <a class="header-anchor" href="#目标" aria-label="Permalink to &quot;目标&quot;">​</a></h1><blockquote><p>之前我只是确认了诸如<code>qiankun</code>等工具对我没有帮助，直到遇到无法克服的问题，我才不得不自行设计一个框架 当时摆在我面前的是这么一个情况：</p></blockquote><ol><li>最新的项目和未来的项目都是<code>vite</code>构建</li><li>很多老旧的项目仍是服务端渲染，不是<code>ssr</code>而是类似<code>jsp</code>，没有使用到<code>vue</code>等视图框架</li><li>通过浏览器插件，往现有项目直接插入仪表盘，且保持隔离，尤其是样式隔离</li><li>老旧项目若作为子项目，应保留<code>seo</code>的效果</li><li>模块联邦的部分也要进行隔离</li></ol><p>这也就等同于</p><ol><li>框架能够优先支持esm，而非仅仅兼容</li><li>没有使用视图框架，意味着没办法通过<code>vue.mount</code>/<code>vue.destroy</code>控制应用挂载与卸载，很难编写暴露的生命周期钩子 框架必须保证子应用在不编写钩子、乃至于不做任何改造下正常运行</li><li>基于<code>web component</code>，支持组件化</li><li>保留子应用的<code>ssr</code>效果</li><li>接收<code>html</code>/<code>js</code>两种入口 其中第1.2条必须做到，第3.4.5条尽力而为，</li></ol><p><code>merak</code>就是按照这个目标前进的：</p><ol><li>完全放弃标签劫持，利用编译端实现改造</li><li>支持<code>iframe</code>模式</li><li>通过<code>proxy</code>,确保子应用的所有部分均在<code>web component</code>中（2.3和无界一致）</li><li>支持<code>ssr</code>模式</li><li>支持库模式</li></ol>',7),t=[i];function a(s,r,n,_,p,m){return o(),l("div",null,t)}const f=e(d,[["render",a]]);export{h as __pageData,f as default};
