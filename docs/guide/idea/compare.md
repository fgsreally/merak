# 比较

相比于其他框架，我认为这些方面是需要被关注的

- **`esm`支持**  

`merak`对不同的打包器，视图框架,模块加载方案一视同仁，可以在任何环境中，获得完全一致的体验


- **高性能**  

1. 从`js`执行层面：   
`merak`只会在`proxy`这一层损失性能，而其他框架会在`proxy`外至少经过一层额外的性能损耗，

2. 从资源请求层面：  
`merak`是等同于原生的请求，而其他框架则存在`custom fetch`去对`fetch`进行重写

3. 从`dom`层面：  
没有对`dom`的追踪，如`garfish`等中，均是对`createElement`做劫持，从而追踪`dom`，`无界`稍有不同,但也追踪了`style`中的相应样式规则

4. 从样式层面：  
没有做任何事情，没有样式追踪，没有样式改造

> 我没有办法举个具体的例子来做对比，因为不同业务场景中负担不同，模拟创建1000个组件然后挂载，这并不符合真实情况，我只能说，性能的损耗，将不会来自于`merak`

> 因为`框架`这个层面不再创造性能消耗，性能问题将完全回归应用本身，微前端不再是用性能换维护的模式，也不再是B端的专属话题，可以在更多的领域尝试它

- **更低的bug可能**  

可以看`wujie`的issue ，很多问题的来源并不是框架本身，而是某个用到的库内部存在奇思妙想，用了一些可能不是那么正规的写法，然后框架本身又劫持了所有的`script`请求与拔插，导致执行环境与单独运行有一定不同，致使这种不正规情况爆发隐患。`merak`本身不对`script`/`style`做任何劫持，仍使用原生请求

- **可拆分的功能**  

其余框架追求内部状态封闭，从而暴露简洁的`api`,很多时候使用者都会从中受益，但一旦遇到特殊的情况，或许是微前端框架自己的`bug`，也或许是特殊的需求，使用者就有点骑虎难下，明明觉得很多功能很合适，但却因为一个小问题不得不放弃使用。

`merak`分为三部分，一部分是编译时，一部分是沙箱，还有一部分是 `Merak`实例+`webcomponent`，控制应用加载和挂载，开发者可以自由拆卸这些功能，

> 比如现在的`ssr`组件，还处于实验状态，你可以保留编译时和沙箱，增加一个自己的`ssr web component`,创建一个`Merak`的子类，修改方法，从而实现自定义的`ssr`效果
> 又比如部分沙箱功能不符合预期，比如你可能不喜欢这种无界式，基于`query`的路由分配，而更喜欢`qiankun`的路由分配，只需要去更改沙箱的`location`,`history`即可（比如库模式，就是舍去了沙箱这两部分[详见]()），又比如，你希望子应用的`load`之类的事件正确触发，那可以自定义沙箱中的`window`规则，[详见]()

5. ssr
目前来讲，应该没有能支持`ssr`的微前端方案，
目前`merak`有实验性的支持（之所以是实验性，并不是它有问题or不可靠，而是其表现与`spa`中有微微不同，我更希望两者能表现相同，所以暂定为实验性），服务端侧的改造可以看`example`,这个没有强制的规定，流式也是支持的

> 补充：`single-spa`有相关尝试，但思路比较奇妙...

### 隐患
<!-- > 很多时候，问题并没有消失，只是从一种变成了另一种 -->
1. 如`eval`/字符串拼凑`script`等依赖运行时创造的环境（动态副作用），无法自动隔离
2. 子应用必须做改造，也就是所有用到的`js`文件必须编译，如未改造的`cdn`中，无法自动隔离
3. 
